using BrickController2.Protocols;
using FluentAssertions;
using Xunit;

namespace BrickController2.Tests.Protocols;

public class PfxProtocolTests
{
    [Fact]
    public void GetStatus_ShouldReturnExpectedByteArray()
    {
        var result = PfxProtocol.GetStatus();

        result.Should().BeEquivalentTo(new byte[]
        {
            0x5B, 0x5B, 0x5B, // CMD_PRE_DELIMITER
            0x01,             // CMD_GET_STATUS
            0xA5, 0x5A, 0x6E, 0x40, 0x54, 0xA4, 0xE5, // Status bytes
            0x5D, 0x5D, 0x5D  // CMD_POST_DELIMITER
        });
    }

    [Fact]
    public void AllOff_ShouldReturnExpectedByteArray()
    {
        var result = PfxProtocol.AllOff();

        result.Should().BeEquivalentTo(new byte[]
        {
            0x5B, 0x5B, 0x5B, // CMD_PRE_DELIMITER
            0x13,             // CMD_TEST_ACTION
            0x01,             // EVT_COMMAND_ALL_OFF
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x5D, 0x5D, 0x5D  // CMD_POST_DELIMITER
        });
    }

    [Theory]
    [InlineData(0, 50, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x71, 0x9F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    [InlineData(1, -100, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x72, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    [InlineData(int.MaxValue, 0, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x73, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    public void SetMotorSpeed_ShouldReturnExpectedByteArray(int channel, short speed, byte[] expected)
    {
        // Act
        var result = PfxProtocol.SetMotorSpeed(channel, speed);

        // Assert
        result.Should().BeEquivalentTo(expected);
    }

    [Theory]
    [InlineData(0, 128, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    [InlineData(1, 255, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    [InlineData(int.MaxValue, 255, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    public void SetBrightness_ShouldReturnExpectedByteArray(int lightChannel, short value, byte[] expected)
    {
        // Act
        var result = PfxProtocol.SetBrightness(lightChannel, value);

        // Assert
        result.Should().BeEquivalentTo(expected);
    }

    [Theory]
    [InlineData(0, 128, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    [InlineData(7, 0, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    [InlineData(int.MaxValue, 255, new byte[] { 0x5B, 0x5B, 0x5B, 0x13, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x5D, 0x5D })]
    public void SetLight_ShouldReturnExpectedByteArray(int lightChannel, short value, byte[] expected)
    {
        // Act
        var result = PfxProtocol.SetLight(lightChannel, value);

        // Assert
        result.Should().BeEquivalentTo(expected);
    }
}
